# 增量分享功能测试检查清单

## 概述
本文档详细描述了增量分享功能的所有测试要点，确保实现满足提案要求并具备良好的性能和稳定性。

## 核心特性
1. **真正的增量检测** - 只检测自上次分享以来修改的文档
2. **分页加载** - 客户端和服务端双重分页保护
3. **并发控制** - 最多5个并发请求
4. **智能重试** - 区分错误类型的自动重试机制
5. **队列管理** - 支持暂停/继续、断点续传
6. **虚拟滚动** - 大数据量下的流畅UI体验
7. **Web Worker** - 异步变更检测不阻塞主线程
8. **缓存机制** - 5分钟有效期内复用检测结果

## 测试环境准备

### 前置条件
- [ ] 确保插件已正确安装
- [ ] 配置好分享服务 API 地址和 Token
- [ ] 准备至少 20 个测试文档（用于测试并发和分页）

---

## 1. 批量分享并发控制测试

### 目标
验证批量分享时最多只有 5 个请求同时执行

### 测试步骤
1. **准备数据**
   - [ ] 创建 10-15 个测试文档
   - [ ] 确保这些文档未分享或需要更新

2. **执行测试**
   - [ ] 打开增量分享界面
   - [ ] 全选所有文档
   - [ ] 点击"批量分享"按钮
   - [ ] 观察浏览器开发者工具的 Network 标签

3. **验证点**
   - [ ] Network 面板中同时进行的请求不超过 5 个
   - [ ] 查看控制台日志，确认有"并发数限制为5"的日志
   - [ ] 所有文档最终都能成功分享

4. **预期结果**
   ```
   控制台输出示例：
   [incremental-share-service] 开始批量分享 12 个文档，并发数限制为5
   [incremental-share-service] 分享文档成功: 文档1
   [incremental-share-service] 分享文档成功: 文档2
   ...
   ```

---

## 2. 智能重试机制测试

### 2.1 网络错误重试（指数退避）

#### 测试步骤
1. **模拟网络错误**
   - [ ] 打开浏览器开发者工具 -> Network 标签
   - [ ] 找到分享请求，右键选择 "Block request URL"
   - [ ] 或者临时断开网络连接

2. **执行分享**
   - [ ] 选择一个文档进行分享
   - [ ] 观察控制台输出

3. **验证点**
   - [ ] 确认有 3 次重试（总共 4 次请求）
   - [ ] 第 1 次重试延迟 1 秒
   - [ ] 第 2 次重试延迟 2 秒
   - [ ] 第 3 次重试延迟 4 秒
   - [ ] 最终显示失败消息

4. **预期输出**
   ```
   [网络错误] 文档 xxx 分享失败，将在 1000ms 后重试 (1/3)
   [网络错误] 文档 xxx 分享失败，将在 2000ms 后重试 (2/3)
   [网络错误] 文档 xxx 分享失败，将在 4000ms 后重试 (3/3)
   文档 xxx 分享失败，已达到最大重试次数 (3)
   ```

### 2.2 服务端 5xx 错误重试

#### 测试步骤
1. **模拟 5xx 错误**
   - [ ] 需要后端配合返回 500/502/503 状态码
   - [ ] 或使用代理工具（如 Charles）修改响应

2. **验证点**
   - [ ] 确认延迟 30 秒后重试
   - [ ] 控制台有明确的 5xx 错误日志

3. **预期输出**
   ```
   [5xx错误] 文档 xxx 分享失败，状态码: 500，将在30秒后重试 (1/3)
   ```

### 2.3 客户端 4xx 错误（立即失败）

#### 测试步骤
1. **模拟 4xx 错误**
   - [ ] 使用无效的 Token 或参数
   - [ ] 触发 400/401/403 等错误

2. **验证点**
   - [ ] 不进行重试，立即失败
   - [ ] 显示详细的错误信息

3. **预期输出**
   ```
   [4xx错误] 文档 xxx 分享失败，状态码: 401，错误信息: Unauthorized
   ```

---

## 3. 分享队列管理测试

### 3.1 暂停/继续功能

#### 测试步骤
1. **准备数据**
   - [ ] 选择 20 个文档进行批量分享

2. **执行测试**
   - [ ] 点击"批量分享"按钮
   - [ ] 在分享过程中（约 3-5 个文档完成后）
   - [ ] 调用 `pluginInstance.incrementalShareService.queueService.pauseQueue()`
   - [ ] 观察分享是否暂停
   - [ ] 调用 `pluginInstance.incrementalShareService.queueService.resumeQueue()`
   - [ ] 观察分享是否继续

3. **验证点**
   - [ ] 暂停后不再有新的分享请求
   - [ ] 已经在处理的请求完成后停止
   - [ ] 继续后从暂停处恢复
   - [ ] 控制台有"队列已暂停"和"队列已继续"日志

4. **测试代码**
   ```javascript
   // 在浏览器控制台执行
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   
   // 暂停
   service.incrementalShareService.queueService.pauseQueue()
   
   // 继续
   service.incrementalShareService.queueService.resumeQueue()
   ```

### 3.2 断点续传功能

#### 测试步骤
1. **执行分享**
   - [ ] 开始批量分享 20 个文档
   - [ ] 在分享进行到一半时（约 10 个完成）

2. **重启思源**
   - [ ] 关闭思源笔记
   - [ ] 重新打开思源笔记

3. **验证点**
   - [ ] 控制台有"检测到未完成的队列，已恢复并暂停"日志
   - [ ] 队列状态为 "paused"
   - [ ] 已完成的任务保持 "success" 状态
   - [ ] 未完成的任务保持 "pending" 状态
   - [ ] 可以手动继续剩余任务

4. **验证代码**
   ```javascript
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   const queue = service.incrementalShareService.queueService.getCurrentQueue()
   
   console.log('队列状态:', queue.status)
   console.log('总任务数:', queue.tasks.length)
   console.log('成功:', queue.tasks.filter(t => t.status === 'success').length)
   console.log('待处理:', queue.tasks.filter(t => t.status === 'pending').length)
   ```

### 3.3 进度显示和预估时间

#### 测试步骤
1. **执行分享**
   - [ ] 批量分享 15 个文档
   - [ ] 在分享过程中持续查看进度

2. **验证点**
   - [ ] 进度实时更新
   - [ ] 显示已完成/总数
   - [ ] 显示成功/失败/跳过数量
   - [ ] 显示预估剩余时间（秒）

3. **查看进度代码**
   ```javascript
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   const progress = service.incrementalShareService.queueService.getProgress()
   
   console.log('进度:', progress)
   // 输出示例:
   // {
   //   total: 15,
   //   completed: 7,
   //   success: 6,
   //   failed: 1,
   //   skipped: 0,
   //   processing: 2,
   //   pending: 6,
   //   estimatedTimeRemaining: 24000 // 毫秒
   // }
   ```

### 3.4 仅重试失败项

#### 测试步骤
1. **制造失败**
   - [ ] 批量分享时，手动阻止部分请求（使失败）
   - [ ] 等待分享完成

2. **重试失败项**
   ```javascript
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   
   // 查看失败的任务
   const failedTasks = service.incrementalShareService.queueService.getFailedTasks()
   console.log('失败任务:', failedTasks)
   
   // 重置失败任务为待处理
   await service.incrementalShareService.queueService.retryFailedTasks()
   ```

3. **验证点**
   - [ ] 失败任务状态变为 "pending"
   - [ ] retryCount 增加
   - [ ] 可以重新执行分享

---

## 4. 虚拟滚动测试

### 测试步骤
1. **准备大量数据**
   - [ ] 准备至少 200-300 个测试文档
   - [ ] 确保部分需要更新

2. **打开增量分享界面**
   - [ ] 观察文档列表渲染速度
   - [ ] 使用浏览器性能工具检查 DOM 节点数量

3. **验证点**
   - [ ] 即使有 300 个文档，界面仍然流畅
   - [ ] DOM 中只渲染可见的约 100 个文档节点
   - [ ] 滚动时动态加载新的文档项
   - [ ] 没有明显的卡顿或延迟

4. **性能检查**
   - [ ] 打开 Chrome DevTools -> Performance
   - [ ] 录制滚动操作
   - [ ] FPS 应保持在 50+ 以上

---

## 5. Web Worker 变更检测测试

### 测试步骤
1. **准备数据**
   - [ ] 准备 500-1000 个文档（测试大数据场景）

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 点击"刷新"按钮触发变更检测

3. **验证点**
   - [ ] 检测过程中 UI 不卡顿
   - [ ] 可以正常滚动和点击其他按钮
   - [ ] 控制台没有阻塞主线程的警告
   - [ ] 检测结果正确分类（新增/更新/未变更）

4. **性能对比**
   ```javascript
   // 测试性能
   console.time('变更检测')
   // 注意：现在需要传入分页函数而不是所有文档
   await service.incrementalShareService.detectChangedDocumentsSinglePage(
     async (pageNum, pageSize) => {
       // 返回一页文档，只包含自上次分享以来修改的文档
       const config = await service.safeLoad('share-pro')
       const lastShareTime = config.appConfig?.incrementalShareConfig?.lastShareTime
       return await getDocumentsPaged(kernelApi, pageNum, pageSize, lastShareTime)
     },
     0,  // pageNum
     500 // pageSize
   )
   console.timeEnd('变更检测')
   
   // 1000 文档应该 < 2秒
   ```

---

## 6. 缓存机制测试

### 6.1 缓存生效测试

#### 测试步骤
1. **第一次检测**
   - [ ] 打开增量分享界面
   - [ ] 记录检测耗时
   - [ ] 观察控制台日志

2. **第二次检测（5分钟内）**
   - [ ] 关闭界面
   - [ ] 立即重新打开增量分享界面
   - [ ] 观察控制台日志

3. **验证点**
   - [ ] 第二次检测显示"使用缓存的变更检测结果"
   - [ ] 第二次检测几乎瞬间完成
   - [ ] 结果与第一次完全一致

### 6.2 缓存失效测试

#### 测试步骤
1. **等待 5 分钟**
   - [ ] 执行第一次检测
   - [ ] 等待超过 5 分钟

2. **第二次检测**
   - [ ] 重新打开界面
   - [ ] 观察是否重新检测

3. **验证点**
   - [ ] 缓存过期后重新执行检测
   - [ ] 控制台显示"变更检测结果（已缓存）"

### 6.3 缓存清除测试

#### 测试步骤
1. **执行分享后**
   - [ ] 进行一次变更检测（建立缓存）
   - [ ] 分享部分文档
   - [ ] 立即刷新界面

2. **验证点**
   - [ ] 分享成功后缓存被自动清除
   - [ ] 下次检测会重新执行，结果会更新

---

## 7. 黑名单集成测试

### 测试步骤
1. **设置黑名单**
   - [ ] 将部分文档添加到黑名单
   - [ ] 将某个笔记本添加到黑名单

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 观察检测结果

3. **验证点**
   - [ ] 黑名单中的文档不出现在待分享列表
   - [ ] 黑名单笔记本下的所有文档都被过滤
   - [ ] 统计信息中显示正确的黑名单数量
   - [ ] 使用 HashSet 数据结构（O(1) 查询）

---

## 8. 服务端分页保护测试

### 目标
验证大量文档操作时，客户端会自动分页请求，避免给服务端造成压力

### 8.1 黑名单检查分页

#### 测试步骤
1. **准备数据**
   - [ ] 准备 300 个测试文档
   - [ ] 设置部分文档在黑名单中

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 观察浏览器 Network 面板

3. **验证点**
   - [ ] 黑名单检查请求分批发送（每批最多 100 个文档 ID）
   - [ ] 控制台显示检查进度日志
   - [ ] 所有文档最终都被正确检查

4. **预期输出**
   ```
   [incremental-share-service] 黑名单检查进度: 100/300
   [incremental-share-service] 黑名单检查进度: 200/300
   [incremental-share-service] 黑名单检查进度: 300/300
   ```

### 8.2 分享历史获取分页

#### 测试步骤
1. **准备数据**
   - [ ] 服务端已有 500+ 条分享历史记录

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 观察 Network 面板的 listDoc 请求

3. **验证点**
   - [ ] listDoc 请求自动分页（每页 100 条）
   - [ ] 自动获取所有分页直到 hasMore 为 false
   - [ ] 控制台显示"获取分享历史完成，共 XXX 条记录"
   - [ ] 有安全检查，最多查询 100 页（防止无限循环）

4. **查看请求**
   - Network 面板应该看到多个 listDoc 请求：
   ```
   POST /api/share/listDoc  {pageNum: 0, pageSize: 100}
   POST /api/share/listDoc  {pageNum: 1, pageSize: 100}
   POST /api/share/listDoc  {pageNum: 2, pageSize: 100}
   ...
   ```

### 8.3 服务端压力测试

#### 测试步骤
1. **极限场景**
   - [ ] 1000 个文档同时进行变更检测
   - [ ] 观察服务端负载

2. **验证点**
   - [ ] 黑名单检查分 10 次请求（每次 100 个）
   - [ ] 分享历史自动分页获取
   - [ ] 服务端不会因为单次请求过大而报错或超时
   - [ ] 整体检测时间在可接受范围内（< 10秒）

---

## 9. 真正的分页加载测试（禁止全部加载）

### 目标
验证 UI 层不会一次性加载所有文档，而是按需分页加载，杜绝客户端内存爆炸

### 9.1 首次加载测试

#### 测试步骤
1. **准备大量数据**
   - [ ] 准备 2000+ 个测试文档

2. **监控首次加载**
   - [ ] 打开增量分享界面
   - [ ] 观察 Network 面板
   - [ ] 查看控制台日志

3. **验证点**
   - [ ] 首次只加载第一页（500个文档）
   - [ ] 控制台显示 "变更检测进度: 1-500/2000"
   - [ ] UI 正常显示前 500 个文档
   - [ ] 内存使用稳定，不会飙升
   - [ ] **绝不出现一次性加载 2000 个文档的情况**

### 9.2 滚动加载测试

#### 测试步骤
1. **滚动到底部**
   - [ ] 滚动到底部触发加载
   - [ ] 观察是否自动加载第二页
   - [ ] 查看 Network 面板和控制台

2. **验证点**
   - [ ] 控制台显示 "变更检测进度: 501-1000/2000"
   - [ ] UI 显示前 1000 个文档
   - [ ] 依此类推直到加载完所有文档
   - [ ] **每次只加载 500 个文档，绝不一次性加载全部**

### 9.3 内存使用测试

#### 测试步骤
1. **监控内存**
   - [ ] 打开 Chrome DevTools -> Memory
   - [ ] 记录初始内存使用
   - [ ] 加载 5000 个文档的增量分享界面
   - [ ] 持续滚动加载所有文档

2. **验证点**
   - [ ] 内存使用平稳增长而非突增
   - [ ] JS Heap Size 增长平缓
   - [ ] **绝不出现内存使用突然飙升的情况**
   - [ ] GC 正常回收内存

### 9.4 性能验证

#### 测试步骤
1. **性能测试**
   - [ ] 每页加载时间 < 2秒
   - [ ] UI 始终保持响应
   - [ ] 滚动流畅无卡顿

2. **验证点**
   - [ ] 用户体验良好，无白屏等待
   - [ ] 任何时候都可以交互
   - [ ] **绝不会因为加载大量数据而卡死**

### 9.5 边界情况测试

#### 测试步骤
1. **边界测试**
   - [ ] 只有 100 个文档时正确加载
   - [ ] 没有文档时显示空状态
   - [ ] 最后一页不足 500 个时正确处理

2. **验证点**
   - [ ] 各种边界情况处理正确
   - [ ] 不会出现数组越界或空指针异常
   - [ ] **绝不因为边界情况导致全部加载**

---

## 10. 综合压力测试

### 测试场景
模拟真实使用场景，测试所有功能的协同工作

1. **大规模数据测试**
   - [ ] 1000 个文档的变更检测
   - [ ] 100 个黑名单项
   - [ ] 同时分享 50 个文档

2. **长时间运行测试**
   - [ ] 连续执行 10 次批量分享
   - [ ] 观察内存占用是否持续增长
   - [ ] 检查是否有内存泄漏

3. **异常场景测试**
   - [ ] 网络频繁中断
   - [ ] 服务端间歇性 500 错误
   - [ ] 中途暂停多次
   - [ ] 系统重启恢复

---

## 11. 真正的增量检测测试

### 目标
验证增量分享只检测自上次分享以来修改的文档，而不是所有文档

### 11.1 增量时间戳测试

#### 测试步骤
1. **首次分享**
   - [ ] 创建 10 个测试文档
   - [ ] 执行一次完整的批量分享
   - [ ] 记录分享完成时间 T1

2. **修改部分文档**
   - [ ] 等待 1 分钟
   - [ ] 修改其中 3 个文档
   - [ ] 保持其他 7 个文档不变

3. **增量检测**
   - [ ] 重新打开增量分享界面
   - [ ] 观察检测结果

#### 验证点
- [ ] 只检测到 3 个修改的文档
- [ ] 控制台显示 SQL 查询包含时间条件
- [ ] `lastShareTime` 正确传递给 SQL 查询
- [ ] **绝不检测所有 10 个文档**

#### 预期 SQL
```
SELECT ... FROM blocks b 
WHERE ... 
AND b.updated > 1701426645000  -- 上次分享时间戳 (Unix timestamp)
ORDER BY b.updated DESC
```

### 11.2 首次分享测试

#### 测试步骤
1. **全新用户**
   - [ ] 新安装插件
   - [ ] `incrementalShareConfig.lastShareTime` 为 undefined

2. **首次检测**
   - [ ] 打开增量分享界面
   - [ ] 观察 SQL 查询

#### 验证点
- [ ] SQL 查询不包含时间条件（检测所有文档）
- [ ] 检测到所有需要分享的文档
- [ ] 分享完成后正确设置 `lastShareTime`

### 11.3 时间戳更新测试

#### 测试步骤
1. **分享完成后**
   - [ ] 执行一次完整的批量分享
   - [ ] 观察 `incrementalShareConfig.lastShareTime` 是否更新

2. **验证点**
   - [ ] 分享成功后，`lastShareTime` 被设置为当前时间戳
   - [ ] 时间戳格式正确（Unix timestamp，毫秒级）
   - [ ] 配置被正确保存到本地和服务端
   - [ ] 下次检测时正确使用新的时间戳

#### 预期行为
```
控制台输出示例：
[incremental-share-service] 最后分享时间已更新: 1701426645000
```

### 11.4 增量检测性能测试

#### 目标
验证增量检测相比全量检测的性能优势

#### 测试步骤
1. **全量检测测试**
   - [ ] 清除 `lastShareTime` 或设置为 undefined
   - [ ] 准备 1000 个文档
   - [ ] 执行变更检测
   - [ ] 记录检测时间和资源消耗

2. **增量检测测试**
   - [ ] 确保 `lastShareTime` 已设置
   - [ ] 只修改其中 50 个文档
   - [ ] 执行变更检测
   - [ ] 记录检测时间和资源消耗

#### 验证点
- [ ] 增量检测只处理 50 个修改的文档
- [ ] 增量检测时间显著短于全量检测
- [ ] 增量检测内存使用更少
- [ ] SQL 查询正确包含时间条件过滤

#### 预期结果
```
全量检测：
- 处理文档数: 1000
- 检测时间: ~3000ms
- 内存使用: ~50MB

增量检测：
- 处理文档数: 50
- 检测时间: ~200ms
- 内存使用: ~5MB

性能提升: 15倍时间效率，10倍内存效率
```

### 11.5 边界情况测试

#### 测试步骤
1. **时间戳为未来时间**
   - [ ] 设置 `lastShareTime` 为未来的某个时间戳
   - [ ] 执行增量检测
   - [ ] 验证不会返回任何文档

2. **时间戳为负数或无效值**
   - [ ] 设置 `lastShareTime` 为负数或 NaN
   - [ ] 执行增量检测
   - [ ] 验证降级为全量检测

3. **时间戳很久以前**
   - [ ] 设置 `lastShareTime` 为一年前的时间戳
   - [ ] 执行增量检测
   - [ ] 验证返回所有文档（因为所有文档都比这个时间新）

#### 验证点
- [ ] 各种异常时间戳都能正确处理
- [ ] 不会出现 SQL 错误或程序崩溃
- [ ] 有合理的降级机制
- [ ] 用户体验不受影响

---

## 12. 统一分页UI测试

### 目标
验证新的统一分页UI设计，替代原有的分组标签页设计

### 12.1 UI布局测试

#### 测试步骤
1. **打开增量分享界面**
   - [ ] 界面正常加载
   - [ ] 不再显示"新增文档"、"更新文档"、"未变更文档"三个分组标签页
   - [ ] 显示统一的文档列表区域

2. **验证UI元素**
   - [ ] 顶部统计信息区域显示新文档和更新文档的数量
   - [ ] 主区域显示统一的文档列表
   - [ ] 文档列表项包含文档标题、类型标识（新增/更新）、最后分享时间
   - [ ] 顶部有全选复选框
   - [ ] 底部显示分页控件

#### 验证点
- [ ] 界面布局清晰，信息层次分明
- [ ] 文档类型通过颜色标签区分（绿色=新增，橙色=更新）
- [ ] 不再显示"未变更文档"分组
- [ ] 所有可分享文档（新增+更新）显示在同一列表中

### 12.2 分页功能测试

#### 测试步骤
1. **准备数据**
   - [ ] 准备超过10个需要分享的文档（新文档+更新文档）

2. **验证分页控件**
   - [ ] 页面底部显示分页控件
   - [ ] 显示当前页码和总页数（如：1/3）
   - [ ] 有"上一页"和"下一页"按钮
   - [ ] 按钮状态根据当前页码正确启用/禁用

3. **测试分页切换**
   - [ ] 点击"下一页"按钮
   - [ ] 观察页面内容更新
   - [ ] 页码信息更新
   - [ ] 继续翻页直到最后一页
   - [ ] 测试"上一页"按钮功能

#### 验证点
- [ ] 每页显示5条记录（根据新的pageSize设置）
- [ ] 分页切换流畅，无卡顿
- [ ] 分页控件状态正确（首页时"上一页"禁用，末页时"下一页"禁用）
- [ ] 分页过程中保持筛选和搜索状态

### 12.3 文档选择测试

#### 测试步骤
1. **全选功能**
   - [ ] 勾选顶部全选框
   - [ ] 当前页所有文档被选中
   - [ ] 取消全选框勾选
   - [ ] 当前页所有文档取消选中

2. **单个选择**
   - [ ] 选择几个文档
   - [ ] 验证选中状态正确
   - [ ] 全选框状态根据选择情况更新（部分选中时显示半选状态）

3. **跨页选择**
   - [ ] 在第一页选择几个文档
   - [ ] 切换到第二页选择几个文档
   - [ ] 切回第一页验证之前的选择状态保持

#### 验证点
- [ ] 选择功能正常工作
- [ ] 全选状态正确计算
- [ ] 跨页选择状态保持
- [ ] 批量分享按钮根据选择数量正确启用/禁用

### 12.4 搜索和筛选测试

#### 测试步骤
1. **搜索功能**
   - [ ] 在搜索框输入关键词
   - [ ] 观察文档列表实时过滤
   - [ ] 验证分页信息更新（总页数可能减少）
   - [ ] 清空搜索框验证显示所有文档

2. **类型识别**
   - [ ] 验证新增文档显示绿色"新增"标签
   - [ ] 验证更新文档显示橙色"更新"标签
   - [ ] 搜索时类型标签仍然正确显示

#### 验证点
- [ ] 搜索功能实时响应
- [ ] 搜索结果正确分页
- [ ] 文档类型标识清晰可见
- [ ] 搜索不影响已选择的文档状态

## 13. Mock数据测试

### 目标
验证在加载失败时能够正确显示mock数据，便于开发和测试

### 13.1 Mock数据加载测试

#### 测试步骤
1. **触发加载失败**
   - [ ] 断开网络连接或关闭思源服务
   - [ ] 打开增量分享界面
   - [ ] 观察是否显示mock数据

2. **验证mock数据内容**
   - [ ] 界面正常显示mock的新文档（25个）
   - [ ] 界面正常显示mock的更新文档（15个）
   - [ ] 统计信息区域显示正确的数量（新文档25，更新文档15，黑名单3）
   - [ ] 文档列表显示mock文档标题
   - [ ] 新文档显示绿色"新增"标签
   - [ ] 更新文档显示橙色"更新"标签

#### 验证点
- [ ] 加载失败时自动切换到mock数据
- [ ] mock数据格式正确，不导致UI错误
- [ ] 所有UI功能在mock数据下正常工作
- [ ] 分页功能在mock数据下正常工作
- [ ] 选择功能在mock数据下正常工作

### 13.2 Mock数据分页测试

#### 测试步骤
1. **验证分页信息**
   - [ ] 分页控件显示正确的总页数（40个文档，每页5个，应显示8页）
   - [ ] 当前页码显示正确

2. **测试分页切换**
   - [ ] 在mock数据状态下尝试分页切换
   - [ ] 验证分页按钮状态正确

#### 验证点
- [ ] mock数据下的分页信息计算正确
- [ ] 分页控件在mock数据下正常工作
- [ ] 不会出现分页错误或异常

### 13.3 Mock数据交互测试

#### 测试步骤
1. **文档选择测试**
   - [ ] 在mock数据下选择几个文档
   - [ ] 验证选择状态正确
   - [ ] 验证全选功能正常

2. **搜索测试**
   - [ ] 在mock数据下使用搜索功能
   - [ ] 验证搜索结果正确过滤

3. **批量分享测试**
   - [ ] 在mock数据下选择文档并尝试批量分享
   - [ ] 验证分享功能正常调用（即使实际不会分享mock数据）

#### 验证点
- [ ] 所有交互功能在mock数据下正常工作
- [ ] 不会因为使用mock数据而导致功能异常
- [ ] 用户体验与真实数据一致
