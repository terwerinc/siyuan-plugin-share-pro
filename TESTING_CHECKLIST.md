# 增量分享功能测试检查清单

## 测试环境准备

### 前置条件
- [ ] 确保插件已正确安装
- [ ] 配置好分享服务 API 地址和 Token
- [ ] 准备至少 20 个测试文档（用于测试并发和分页）

---

## 1. 批量分享并发控制测试

### 目标
验证批量分享时最多只有 5 个请求同时执行

### 测试步骤
1. **准备数据**
   - [ ] 创建 10-15 个测试文档
   - [ ] 确保这些文档未分享或需要更新

2. **执行测试**
   - [ ] 打开增量分享界面
   - [ ] 全选所有文档
   - [ ] 点击"批量分享"按钮
   - [ ] 观察浏览器开发者工具的 Network 标签

3. **验证点**
   - [ ] Network 面板中同时进行的请求不超过 5 个
   - [ ] 查看控制台日志，确认有"并发数限制为5"的日志
   - [ ] 所有文档最终都能成功分享

4. **预期结果**
   ```
   控制台输出示例：
   [incremental-share-service] 开始批量分享 12 个文档，并发数限制为5
   [incremental-share-service] 分享文档成功: 文档1
   [incremental-share-service] 分享文档成功: 文档2
   ...
   ```

---

## 2. 智能重试机制测试

### 2.1 网络错误重试（指数退避）

#### 测试步骤
1. **模拟网络错误**
   - [ ] 打开浏览器开发者工具 -> Network 标签
   - [ ] 找到分享请求，右键选择 "Block request URL"
   - [ ] 或者临时断开网络连接

2. **执行分享**
   - [ ] 选择一个文档进行分享
   - [ ] 观察控制台输出

3. **验证点**
   - [ ] 确认有 3 次重试（总共 4 次请求）
   - [ ] 第 1 次重试延迟 1 秒
   - [ ] 第 2 次重试延迟 2 秒
   - [ ] 第 3 次重试延迟 4 秒
   - [ ] 最终显示失败消息

4. **预期输出**
   ```
   [网络错误] 文档 xxx 分享失败，将在 1000ms 后重试 (1/3)
   [网络错误] 文档 xxx 分享失败，将在 2000ms 后重试 (2/3)
   [网络错误] 文档 xxx 分享失败，将在 4000ms 后重试 (3/3)
   文档 xxx 分享失败，已达到最大重试次数 (3)
   ```

### 2.2 服务端 5xx 错误重试

#### 测试步骤
1. **模拟 5xx 错误**
   - [ ] 需要后端配合返回 500/502/503 状态码
   - [ ] 或使用代理工具（如 Charles）修改响应

2. **验证点**
   - [ ] 确认延迟 30 秒后重试
   - [ ] 控制台有明确的 5xx 错误日志

3. **预期输出**
   ```
   [5xx错误] 文档 xxx 分享失败，状态码: 500，将在30秒后重试 (1/3)
   ```

### 2.3 客户端 4xx 错误（立即失败）

#### 测试步骤
1. **模拟 4xx 错误**
   - [ ] 使用无效的 Token 或参数
   - [ ] 触发 400/401/403 等错误

2. **验证点**
   - [ ] 不进行重试，立即失败
   - [ ] 显示详细的错误信息

3. **预期输出**
   ```
   [4xx错误] 文档 xxx 分享失败，状态码: 401，错误信息: Unauthorized
   ```

---

## 3. 分享队列管理测试

### 3.1 暂停/继续功能

#### 测试步骤
1. **准备数据**
   - [ ] 选择 20 个文档进行批量分享

2. **执行测试**
   - [ ] 点击"批量分享"按钮
   - [ ] 在分享过程中（约 3-5 个文档完成后）
   - [ ] 调用 `pluginInstance.incrementalShareService.queueService.pauseQueue()`
   - [ ] 观察分享是否暂停
   - [ ] 调用 `pluginInstance.incrementalShareService.queueService.resumeQueue()`
   - [ ] 观察分享是否继续

3. **验证点**
   - [ ] 暂停后不再有新的分享请求
   - [ ] 已经在处理的请求完成后停止
   - [ ] 继续后从暂停处恢复
   - [ ] 控制台有"队列已暂停"和"队列已继续"日志

4. **测试代码**
   ```javascript
   // 在浏览器控制台执行
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   
   // 暂停
   service.incrementalShareService.queueService.pauseQueue()
   
   // 继续
   service.incrementalShareService.queueService.resumeQueue()
   ```

### 3.2 断点续传功能

#### 测试步骤
1. **执行分享**
   - [ ] 开始批量分享 20 个文档
   - [ ] 在分享进行到一半时（约 10 个完成）

2. **重启思源**
   - [ ] 关闭思源笔记
   - [ ] 重新打开思源笔记

3. **验证点**
   - [ ] 控制台有"检测到未完成的队列，已恢复并暂停"日志
   - [ ] 队列状态为 "paused"
   - [ ] 已完成的任务保持 "success" 状态
   - [ ] 未完成的任务保持 "pending" 状态
   - [ ] 可以手动继续剩余任务

4. **验证代码**
   ```javascript
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   const queue = service.incrementalShareService.queueService.getCurrentQueue()
   
   console.log('队列状态:', queue.status)
   console.log('总任务数:', queue.tasks.length)
   console.log('成功:', queue.tasks.filter(t => t.status === 'success').length)
   console.log('待处理:', queue.tasks.filter(t => t.status === 'pending').length)
   ```

### 3.3 进度显示和预估时间

#### 测试步骤
1. **执行分享**
   - [ ] 批量分享 15 个文档
   - [ ] 在分享过程中持续查看进度

2. **验证点**
   - [ ] 进度实时更新
   - [ ] 显示已完成/总数
   - [ ] 显示成功/失败/跳过数量
   - [ ] 显示预估剩余时间（秒）

3. **查看进度代码**
   ```javascript
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   const progress = service.incrementalShareService.queueService.getProgress()
   
   console.log('进度:', progress)
   // 输出示例:
   // {
   //   total: 15,
   //   completed: 7,
   //   success: 6,
   //   failed: 1,
   //   skipped: 0,
   //   processing: 2,
   //   pending: 6,
   //   estimatedTimeRemaining: 24000 // 毫秒
   // }
   ```

### 3.4 仅重试失败项

#### 测试步骤
1. **制造失败**
   - [ ] 批量分享时，手动阻止部分请求（使失败）
   - [ ] 等待分享完成

2. **重试失败项**
   ```javascript
   const service = window.siyuan.ws.app.plugins.find(p => p.name === 'share-pro')
   
   // 查看失败的任务
   const failedTasks = service.incrementalShareService.queueService.getFailedTasks()
   console.log('失败任务:', failedTasks)
   
   // 重置失败任务为待处理
   await service.incrementalShareService.queueService.retryFailedTasks()
   ```

3. **验证点**
   - [ ] 失败任务状态变为 "pending"
   - [ ] retryCount 增加
   - [ ] 可以重新执行分享

---

## 4. 虚拟滚动测试

### 测试步骤
1. **准备大量数据**
   - [ ] 准备至少 200-300 个测试文档
   - [ ] 确保部分需要更新

2. **打开增量分享界面**
   - [ ] 观察文档列表渲染速度
   - [ ] 使用浏览器性能工具检查 DOM 节点数量

3. **验证点**
   - [ ] 即使有 300 个文档，界面仍然流畅
   - [ ] DOM 中只渲染可见的约 100 个文档节点
   - [ ] 滚动时动态加载新的文档项
   - [ ] 没有明显的卡顿或延迟

4. **性能检查**
   - [ ] 打开 Chrome DevTools -> Performance
   - [ ] 录制滚动操作
   - [ ] FPS 应保持在 50+ 以上

---

## 5. Web Worker 变更检测测试

### 测试步骤
1. **准备数据**
   - [ ] 准备 500-1000 个文档（测试大数据场景）

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 点击"刷新"按钮触发变更检测

3. **验证点**
   - [ ] 检测过程中 UI 不卡顿
   - [ ] 可以正常滚动和点击其他按钮
   - [ ] 控制台没有阻塞主线程的警告
   - [ ] 检测结果正确分类（新增/更新/未变更）

4. **性能对比**
   ```javascript
   // 测试性能
   console.time('变更检测')
   await service.incrementalShareService.detectChangedDocuments(allDocuments)
   console.timeEnd('变更检测')
   
   // 1000 文档应该 < 2秒
   // 5000 文档应该 < 5秒
   ```

---

## 6. 缓存机制测试

### 6.1 缓存生效测试

#### 测试步骤
1. **第一次检测**
   - [ ] 打开增量分享界面
   - [ ] 记录检测耗时
   - [ ] 观察控制台日志

2. **第二次检测（5分钟内）**
   - [ ] 关闭界面
   - [ ] 立即重新打开增量分享界面
   - [ ] 观察控制台日志

3. **验证点**
   - [ ] 第二次检测显示"使用缓存的变更检测结果"
   - [ ] 第二次检测几乎瞬间完成
   - [ ] 结果与第一次完全一致

### 6.2 缓存失效测试

#### 测试步骤
1. **等待 5 分钟**
   - [ ] 执行第一次检测
   - [ ] 等待超过 5 分钟

2. **第二次检测**
   - [ ] 重新打开界面
   - [ ] 观察是否重新检测

3. **验证点**
   - [ ] 缓存过期后重新执行检测
   - [ ] 控制台显示"变更检测结果（已缓存）"

### 6.3 缓存清除测试

#### 测试步骤
1. **执行分享后**
   - [ ] 进行一次变更检测（建立缓存）
   - [ ] 分享部分文档
   - [ ] 立即刷新界面

2. **验证点**
   - [ ] 分享成功后缓存被自动清除
   - [ ] 下次检测会重新执行，结果会更新

---

## 7. 黑名单集成测试

### 测试步骤
1. **设置黑名单**
   - [ ] 将部分文档添加到黑名单
   - [ ] 将某个笔记本添加到黑名单

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 观察检测结果

3. **验证点**
   - [ ] 黑名单中的文档不出现在待分享列表
   - [ ] 黑名单笔记本下的所有文档都被过滤
   - [ ] 统计信息中显示正确的黑名单数量
   - [ ] 使用 HashSet 数据结构（O(1) 查询）

---

## 9. 服务端分页保护测试

### 目标
验证大量文档操作时，客户端会自动分页请求，避免给服务端造成压力

### 9.1 黑名单检查分页

#### 测试步骤
1. **准备数据**
   - [ ] 准备 300 个测试文档
   - [ ] 设置部分文档在黑名单中

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 观察浏览器 Network 面板

3. **验证点**
   - [ ] 黑名单检查请求分批发送（每批最多 100 个文档 ID）
   - [ ] 控制台显示检查进度日志
   - [ ] 所有文档最终都被正确检查

4. **预期输出**
   ```
   [incremental-share-service] 黑名单检查进度: 100/300
   [incremental-share-service] 黑名单检查进度: 200/300
   [incremental-share-service] 黑名单检查进度: 300/300
   ```

### 9.2 分享历史获取分页

#### 测试步骤
1. **准备数据**
   - [ ] 服务端已有 500+ 条分享历史记录

2. **执行检测**
   - [ ] 打开增量分享界面
   - [ ] 观察 Network 面板的 listDoc 请求

3. **验证点**
   - [ ] listDoc 请求自动分页（每页 100 条）
   - [ ] 自动获取所有分页直到 hasMore 为 false
   - [ ] 控制台显示"获取分享历史完成，共 XXX 条记录"
   - [ ] 有安全检查，最多查询 100 页（防止无限循环）

4. **查看请求**
   - Network 面板应该看到多个 listDoc 请求：
   ```
   POST /api/share/listDoc  {pageNum: 0, pageSize: 100}
   POST /api/share/listDoc  {pageNum: 1, pageSize: 100}
   POST /api/share/listDoc  {pageNum: 2, pageSize: 100}
   ...
   ```

### 9.3 服务端压力测试

#### 测试步骤
1. **极限场景**
   - [ ] 1000 个文档同时进行变更检测
   - [ ] 观察服务端负载

2. **验证点**
   - [ ] 黑名单检查分 10 次请求（每次 100 个）
   - [ ] 分享历史自动分页获取
   - [ ] 服务端不会因为单次请求过大而报错或超时
   - [ ] 整体检测时间在可接受范围内（< 10秒）

---

## 10. 综合压力测试

### 测试场景
模拟真实使用场景，测试所有功能的协同工作

#### 测试步骤
1. **大规模数据测试**
   - [ ] 1000 个文档的变更检测
   - [ ] 100 个黑名单项
   - [ ] 同时分享 50 个文档

2. **长时间运行测试**
   - [ ] 连续执行 10 次批量分享
   - [ ] 观察内存占用是否持续增长
   - [ ] 检查是否有内存泄漏

3. **异常场景测试**
   - [ ] 网络频繁中断
   - [ ] 服务端间歇性 500 错误
   - [ ] 中途暂停多次
   - [ ] 系统重启恢复

---

## 测试报告模板

### 测试环境
- 思源版本：
- 插件版本：
- 浏览器：
- 操作系统：

### 测试结果汇总
| 功能模块 | 测试项 | 通过 | 失败 | 备注 |
|---------|--------|------|------|------|
| 并发控制 | 5个并发限制 | ☐ | ☐ |  |
| 智能重试 | 网络错误重试 | ☐ | ☐ |  |
| 智能重试 | 5xx延迟重试 | ☐ | ☐ |  |
| 智能重试 | 4xx立即失败 | ☐ | ☐ |  |
| 队列管理 | 暂停/继续 | ☐ | ☐ |  |
| 队列管理 | 断点续传 | ☐ | ☐ |  |
| 队列管理 | 进度显示 | ☐ | ☐ |  |
| 队列管理 | 重试失败项 | ☐ | ☐ |  |
| 虚拟滚动 | 大量数据渲染 | ☐ | ☐ |  |
| Worker | 非阻塞检测 | ☐ | ☐ |  |
| 缓存 | 5分钟有效期 | ☐ | ☐ |  |
| 缓存 | 自动清除 | ☐ | ☐ |  |

### 发现的问题
1. 
2. 
3. 

### 建议改进
1. 
2. 
3.
